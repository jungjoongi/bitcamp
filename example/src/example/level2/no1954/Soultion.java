package example.level2.no1954;

import java.util.InputMismatchException;
import java.util.Scanner;

public class Soultion {
 
    public static void main(String[] args) {
        
        Scanner sc = new Scanner(System.in);
        int deg; // 차수 입력용
        while(true) {
            System.out.println("달팽이의 차수를 입력하세요 : ");
        try{
            deg = sc.nextInt();
            break;
        }catch(InputMismatchException e){
            System.out.println("숫자만 입력해야 합니다.");
        }
        }
        sc.close();
        
        int n; // 차수를 대입해서 조건식 등에 활용
        
        int col, row; // 행, 열
        
        int k = 0; // 바깥for문이 돌면서 1씩 증가. 2차배열 좌표 식에 필수 조합. 달팽이 알고리즘의 숨은 핵심
        
        int[][] snail = new int[deg][deg]; // 2차배열 생성, 차수 입력
        
        int i = 1; // 순열 
        
        for(n=deg; n>0; n-=2){ // 차수가 0보다 작을 때 종료, n=n-2
                               // ex) deg(n) = 5 --> 3 --> 1 --> (종료) 총 3회 동작
                                            // *k=0  **k=1 ***k=2
                                                                                            // 어떻게 전체반복을 3회로 제한시킬 방법으로 n-=2를 생각해냈을까? 수학잔가?
             for(row=0; row<n; row++){ // 0부터 시작해서 [k]:[k+0] 좌표부터 입력 시작                    // 달팽이 알고리즘 반복식 : n-=2, 고정되는 좌표안에 동적 변수('k',deg,col,row)를 잘 조합해 식 세우기..
                                       // * n = 5. row = 0 -> 1 -> 2 -> 3 -> 4(종료)            // 난 수학자가 아니니까 공식처럼 외우는수밖에..
                                     // ** n = 3. row = 0 -> 1 -> 2(종료)
                                     // *** n = 1. row = 0(종료)
 
                 snail[k][k+row]=i; // * [0][0], [0][1], [0][2], [0][3], [0][4]
                                      // ** [1][1], [1][2], [1][3]
                                   // *** [2][2]
                                                                                            // 가로 첫줄 둘째줄 셋째줄에는 공통적으로 왼쪽(행) 좌표가 고정되어있다.                 
                 i++; // 2차배열에 위처럼 좌표가 설정될때마다 1씩 증가하면서 대입됨.                            // 첫줄 행좌표는 0, 둘째줄은 1, 셋째줄은 2이므로 행좌표에는 1씩 증가하는 증감식 필요.
                      // * [0][0]= 1, [0][1]= 2, [0][2]= 3, [0][3]=4, [0][4]=5                // 근데 마침 k가 0부터 1씩 증가하고 있으므로 그냥 k를 대입하면 됨. 그냥 k는 들어가야됨.
                    // ** [1][1]=17, [1][2]=18, [1][3]=19                                    // 각 행의 오른쪽(열)좌표들은 1씩 이동해야하므로, 1씩 증가하는 row를 대입. 
                   // *** [2][2]=25                                                            // 전체반복때마다 열좌표의 시작지점이 1씩 옮겨지는 것은 row에 증감식k를 더하는것으로 해결. 
                 
             }
             for(col=1; col<n; col++){ // 1부터 시작해서  [k+1][5-k-1] 좌표부터 입력 시작
                                      // * n = 5. col = 1 -> 2 -> 3 -> 4(종료)
                                     // ** n = 3. col = 1 -> 2(종료)
                 
                 snail[k+col][deg-k-1]=i; // * [1][4], [2][4], [3][4], [4][4]
                                          // ** [2][3], [3][3]
                                                                                             // 세로 다섯째줄 넷째줄의 오른쪽(열) 좌표가 고정되어있다.
                 i++; // * [1][4]= 6, [2][4]= 7, [3][4]= 8, [4][4]= 9                        // 출력문을 보면 다섯째줄은 열좌표가 4여야 한다. deg의 값은 5이니까 -1해주면됨.
                     // ** [2][3]=20, [3][3]=21                                                // 넷째줄의 열좌표는 3. 1이 감소되었다. 근데 단순히 1이 감소되는게 아니라 순열로 감소되는 것. 
                                                                                             // 즉 순열 증가하는 수로 한번더 deg에 뺄셈을 해야 한다. 묻지말고 -k 필수 추가
             }
             for(row=1; row<n; row++){ // 1부터 시작해서 [k+5-1][5-k-1-1] 좌표부터 입력 시작
                                     // * n = 5. row = 1 -> 2 -> 3 -> 4(종료)
                                    // ** n = 3. row = 1 -> 2(종료)
                                                                                             // 가로 다섯째줄 넷째줄의 행좌표가 고정되어있다.
                 snail[deg-k-1][deg-k-row-1]=i;                                             // 다섯째줄 행좌표는 4. 넷째줄은 3이므로 deg에 순열k를 빼고 1을 더 빼준다.
                                                // * [4][3], [4][2], [4][1], [4][0]            // 열좌표는 반대로 1씩 감소한다. 숫자가 큰 deg에 k를 빼고 (하여간 k는 무조건 조합하는게 포인트) 
                                                // ** [3][2], [3][1]                            // 1씩 증가하는 row를 한번더 빼고 거기에 1을 더 뺀다.
                 i++;  // * [4][3]=10, [4][2]=11, [4][1]=12, [4][0]=13
                      // ** [3][2]=22, [3][1]=23
             }
             for(col=1; col<n-1; col++){ // 1부터 시작해서 [5-k-1-1][k] 좌표부터 입력 시작
                                         // * n = 5. row = 1 -> 2 -> 3(종료)
                                        // ** n = 3. row = 1(종료)
                 
                 snail[deg-k-col-1][k]=i; // * [3][0], [2][0], [1][0]
                                          // ** [2][1]
                                                                                             // 세로 셋째줄 둘째줄의 열좌표가 고정되어있다.
                 i++; // * [3][0]=14, [2][0]=15, [1][0]=16                                    // 셋째줄 열좌표는 o이다. 무조건 k. 둘째줄되면서 열좌표가 1로 증가한다.
                     // ** [2][1]=24                                                        // 셋째줄 행좌표는 3 -> 2 -> 1로 감소. k는 증가식이니까 숫자큰 deg에서 k를 빼주는걸로.
             }                                                                                // 1을 한번 더 빼주고 거기에 row도 뺴줘야 한다. 이유가 궁금하면 deg에 다른 숫자를 넣어보면 안다.  
             k++;
        }
        
        for(col=0; col<deg; col++){
            for(row=0; row<deg; row++){
                System.out.printf("%3d",snail[col][row]); // 출력문 정렬 (1의자리수 때문)
            }
            System.out.println();
        }                                                                                    // 좌표식들을 보면 규칙성이 보인다.
                                                                                            // 바로전 열 좌표식은 그다음 for문에서 행 좌표식이 된다. 
    } // main                                                                                // 잘 조합하면 역달팽이도 만들 수 있단 얘기다.
} // class
 
